package com.linus.lab.juc.jmm;


/**
 * @author ：wangxiangyu
 * @date ：Created in 2020/8/24
 *
 * 变量的可见性、指令的执行顺序、功能的原子性  这三点是单线程编程过程中完全不需要考虑的问题，但在并发编程中需要着重考虑。
 *
 * CPUCacheLine.java证明了缓存行的存在，CPU的数据缓存基于两种原则：
 * 1、刚被使用的变量，接下来很可能被再次使用，所以需要缓存起来。
 * 2、刚被使用的变量后边的邻居变量，接下来很可能被再次使用，所以可以把整个内存行一起缓存起来。64k
 *
 * 缓存行的存在直接带来了变量的可见性问题，CPU中缓存的值，可能跟主存中的变量已经不一样了。可能带来匪夷所思的后果。
 * CodeVisibility.java证明了这点，循环条件的值被另外一个线程改变了，本应该跳出循环，但实际却跳不出来。
 * 可以通过对变量施加volatile修饰解决这个问题，volatile修饰的变量，每次写会同时写回到主存，每次对会先从主存同步一遍。
 * volatile的实现本质是一种加锁，从汇编指令角度是通过lock前缀去修饰读写操作。
 * 从硬件实现的层面上又分为总线加锁和MESI缓存一致性协议两种方式。
 * 此外，任意能中断CPU执行，造成时间片切换的代码也可以让CodeVisibility.java跳出循环，因为CPU有可能重新读取了新值，比如sleep、sout、Integer+1等等
 *
 * CodeReorder.java证明了指令重排的存在，重排可能是编译期间产生的、也可能是CPU执行的时候造成的
 * (比如指令顺序：a->b，但是执行过程发现b所需的数据已经在缓存行中，可以直接执行，但是a还需要等，这个时候就有可能先执行b，后执行a)。
 * 指令重排的目的还是效率，针对单线程内，as-if-serial原则保证了代码执行的结果是跟顺序执行一致的，但是实际的执行顺序可能不一致。
 * 在多线程环境下，JVM没法判断线程间的代码顺序关系，所以需要开发人员通过volatile、synchronize、thread.start()、Thread.join()等规则显示的告诉JVM哪些代码具有逻辑上的顺序关系。
 * 这就是happens-before原则，一种保障执行结果的原则，具有传递性。通过内存屏障实现。
 * 比如：volatile读写的前后会加入适当的内存的屏障来避免指令重排。
 *
 * CodeAtomic.java证明了功能原则性导致执行结果超出预期的情况。
 * 有两个条件：1、共享变量；2、存在写操作。称为竞态数据。
 * 一般通过同步来解决，synchronized和AQS是两个常见的选择。
 */